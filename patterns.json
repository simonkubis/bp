{
    "patterns": [
        {
            "title": "Secure Embedded Logging",
            "text": "1.1. Intent\nAnswering to the security needs by extending the data logging capabilities in the embedded\nplatforms by adding security modules and services. The proposed pattern can be used to add\nthe logging security features together with a design-focused logging solution.\n1.2. Example\nElectric vehicles contain specialized embedded platforms called Battery Management System\n(BMS), dedicated for control and management of battery cells used to power up the engine\nand other components [1,2]. Different derivations of BMS exist, with the modular and\ndistributed BMS being more common than the others. Each Battery pack contains several\ndedicated sensors alongside battery cells [1]. The battery packs are controlled through Battery\nCell Controllers (BCC), which are assigned to handle the immediate data control and\nthroughput of these individual packs. A central BMS receives individual battery packs data\nfrom the BCCs. This data ranges from the sensor data (e.g., temperature data) to the voltage\nand current of a particular cell. They are used to extract information like state of charge (SoC)\nor state of health (SoH) [3]. Based on the data received, BMS can also store and handle error\nevents.\nWhen a battery pack gets depleted, it needs to be replaced. The replaced battery pack can\noften still be used as an active component for some other appliances, e.g., power grids. Here,\nbattery packs are aimed to be shipped together with their assigned BCCs. In case the BCCs are\nto remain as part of the vehicle and its BMS, a design compromise needs to be established to\nenable the logged operational data to be shipped with the battery pack as well. Since BMS\nwould be mass-produced, a design needs to be made in the earlier phases of the development.\nIt is desirable to enable the porting of the stored memory units together with the battery\npacks as to be able to track the health of the used battery packs or for any additional data\npost-processing. It is of critical importance that only valid battery packs are being transported\nand that it is possible to authenticate the memory units used with the previous battery packs.\nThis constraint is essential to make sure that no malicious attacks through a modified memory\nunit are possible. Additionally, the data that is stored needs also to be secured. The reason for\nmaking it secure is to guard it against any potential malicious attacks or even faults that can\narise from oversights during service and maintenance. The constraint is still present to handle\nthese design steps in the initial development phase. This is done for the fact that the battery\npacks would be mass-produced. Any change that would otherwise be done later could\njeopardize the security of the battery packs and add an additional cost.\n1.3. Context\nAn embedded platform is being designed which uses local memory devices to handle the\nstorage of lifetime logging data. For the reasons of the cost and memory size limitations, as\nwell as not having, or having limited, access to a wide network, it is intended for the platform\nto rely on local solutions rather than remote services. Often, these types of systems are closed\nand protected under a specific group. It is critical that the stored data maintains its integrity\nand is only managed through authorized handlers in this environment. The embedded system\nwould consist of a selection of hardware modules, interfaces, and implemented software\nfunctions. The hardware modules are divided by their respective tasks and placement. These\nare usually tied to a specific architecture and their upgrade can be very difficult, or sometimes\nnot even possible. 1.4. Problem  \nHow to design an embedded platform that is able to securely handle, but also port and verify, \nlogging data from its source to a designated entity?  \nIn embedded platforms that use distributed module placement, log ging process and porting of \nthe logged data often introduce security risks. Porting would need to be done either by using a \nmanual external device or having a connection to a network, both of which might be difficult, \nand even not feasible, under the platf orm constraints. Additionally, changes introduced to the \nsystem on a physical layer may hamper security during the transfer of the saved data and \npresent a high level of porting complexity. Modules used would need to account for security \nfunctionality and have pre -defined elements that supplement them. These considerations \nresult in making it a very challenging and expensive task.  \nDifferent malicious attacks can be mounted aimed directly at the content of the logged data \nduring both the active logging peri od and during the offload transfer period. It is challenging to \nderive a definite list of threats, as these are usually use -case or application dependent . Here \nwe focus primarily on generic threats that are found in embedded logging systems. Specifically, \nwe consider the following main threats:  \n• Spying on the targeted process: If not properly secured, an attacker can derive \ninformation, and even knowledge, from the stored log data by a direct port access.  \n• Logged data tampering: Unauthorized change of the c urrent, or previously stored, log \ncontent. This includes active attacks on the communication points during the ongoing \nlogging process, but also direct tamper attacks on the devices.  \n• Counterfeited sources: Each logged data is tied to an affiliated monitor ed device that is \nalso supplied from a certified manufacturer. During the offload transfer period of the \ndevice, i.e., when the change of the targeted monitored device happens, the device \ncan be replaced with a counterfeited or a malicious one. A different  attack would be \nby using the same device but replacing the data inside it.  \nThe following forces apply to the possible solution:  \n• Streamlined HW/SW integration: Implementation of the hardware and software \nelements associated with the security functionalit y need to be easily replicated across \nmultiple devices and vendors.  \n• Production cost: Changes made to the hardware and software design of the embedded \nsystems can result in an increased manufacturing cost.  \n• Limited resources: The embedded system needs to b e able to execute all necessary \nfunctions under different constraints.  \n• Security - confidentiality and integrity: Necessary measures need to be taken which \nshould prevent the logged data to be tampered or spied on.  \n• Security - authenticity: The logged data  that is stored needs to be able to be properly \nidentified and verified that it comes from a valid source entity. This authenticity is also \nnecessary each time the data needs to be accessed during the active period, i.e., when \nthe data is retrieved for the  analytic or other operational purposes  \n1.5. Solution  \nEnsure that the monitored logged data will be securely protected through an integrated \nsecurity module relaying data to the memory module and authenticated by using necessary \nhardware and software critical c omponents embedded during the deployment phase.  \nWhen implementing a logging procedure as part of the constrained embedded platform, the \nsecurity requirement is achieved by integrating a Security Module (SM) as part of the EC. While \nadding the SM to indivi dual EC devices adds to the overall cost, it does make the system more \ndecentralized. Furthermore, this ensures that the security operations are distributed without \nheavily impacting the performance. EC device vendors could also not guarantee that the \nlogg ed data would be secured since the EC itself would not handle that constraint. Therefore, \nit is necessary to also couple the security operations as part of the EC to appropriately address \nthe security design and attest that the information stored will be p rotected.  \n1.6. Structure  \nFigure 1 depicts the design behind the solution and shows the recommended building blocks. \nThe following components are listed:  \n• Embedded Controller (EC): Contains necessary interfaces for the communication, main \ndriver logic, and the control bridge between the dat a that is to be stored and the \nsecurity driver.  \n• Logging Memory Unit (LMU): Dedicated device for storing the encrypted data; contains \nnecessary description data, encrypted security keys, and the encrypted data.  \n• Security Module (SM): Provides security oper ations; works as a security bridge \nbetween the EC and the LMU.  \n• Source Verification Device (SVD): Device tied to a particular LMU and used for the \nauthentication purpose; can contain necessary authentication data, i.e., private -public \nkey pair, and/or a ce rtificate. It is also generally seen as the device from which logging \nprocess data is retrieved (data source).  \n \nFigure 1: Design -based solution in task separation for handling security logging by providing secure operations and \ndevice authentication.  \nSoftware functions and associated security data would be handled by the SM itself. At the \nsame time, it would use the logic controller of the EC to drive the overall processing and data \npreparation when storing it as part of the loggin g. It is necessary to keep the SM cheap in \ndesign. As a minimum -security requirement when storing the logging data, we propose to use \nencryption and authentication for the stored data. These can either be achieved by using \nseparate security functions or ap plying a suite like Authenticated Encryption (AE) to handle \nthis process. The data integrity check (additional AE data or a separate operation) would be \nsaved in a separate memory block inside the LMU. These, however, do not need to be secured, \nbut they do  need to be checked by the EC from the SM each time a new LMU is authenticated. \nThey also need to be periodically updated from the SM after new data is written. The SM \nshould also offer the functionality of storing and handling the key data used by the sec urity \noperations. Additionally, an EC together with its SM could also provide a Key Derivation \nFunction (KDF). The basic principle of deriving and delivering the keys between the parties is \nleft to the designers. The keys are generally securely encrypted a nd stored in the LMU secure \nsection. The authentication operations can either be managed using symmetric -based \nauthentication, e.g., AES challenge/response mechanism or by using asymmetric \nauthentication, e.g., Public Key Infrastructure (PKI). The security  operations can be handled \nentirely through software or be hardware -derived, where the hardware operations usually \noffer better performance, e.g., hardware implementation of the Advanced Encryption \nStandard (AES). While we consider using the integrated sec urity engine through a dedicated \nSM as the most cost -effective solution, other dedicated hardware security components can \nalso be examined. These include Secure Elements (SE) and Trusted Platform Module (TPM). \nHowever, unlike the integrated secure engine, SE and TPM are more complex to incorporate \nand much more costly.  \n \n\n1.7. Dynamics  \nThe pattern is aimed at providing an affordable and secure solution when transporting and \nthen replacing an LMU.  \nThis process is depicted in Figure 2. Here, a user would receive the LMU together with the SVD \nfrom a previous socket. When integrating it into the new system, it might be necessary to \nverify this memory unit alongside the newly installed SVD, which has been formerly taken out \nfrom the older system. This is achi eved by using the previously explained security verification \nfunctions that the new EC, through its design with SM, would possess as well. The verification \nprocess needs to be successfully completed for the LMU to be further used, be it just for the \nanalyt ic or for continuing operations.  \n \n \nFigure 2: Sequence diagram describing the verification process during the porting of LMU and a SVD from a previous \nto a new embedded device platform.  \n \n1.8. Implementation  \n \n1.9. Example Resolved  \nBased on th e open design question presented in Section 1.2, we present a solution in form of a \nmodule extension. Here, security is applied to guarantee: (i) confidentiality - protecting \nnecessary system data by only providing data associated to the BMS operational cy cle, (ii) \nrepudiation – an action can be tied to the entity that caused it, and (iii) integrity – data has not \nbeen modified. The resulted block design is shown in Figure 3.  \n\nThe security functionality is controlled by an internal SM service engine. The SM  communicates \ndirectly with the EC and the memory interface.  \n \nFigure 3: Realized example based on the SECURE  EMBEDDED  LOGGING  pattern. Applied on a BCC of a BMS by \nextending its applicability for the secure logging process  \nWhen the need arises for a battery pack to be replaced, using this design, it is possible to also \nport the whole BCC easily  or just the memory module with the logged data, as indicated in the \npattern solution. Based on the implementation, the BMS would verify the newly added BCCs, \nwhile a BCC can independently run the verification operation on the connected battery pack \nand me mory module.  \n1.10. Consequences  \nThis section lists the benefits and liabilities found when applying the SEL architectural pattern \nbased on the Forces from Section 1.4. The benefits of the SEL pattern are:  \n• As the pattern suggests using a dedicated security modul e and predefined security \nfunctions per EC, the general production design can be applied on a larger scale.  \n• The pattern proposes the use of a dedicated SM that should allow, at a minimum, \nencryption,  and integrity check for handling the security of the st ored data.  \n• Additionally, the SM needs to allow for a method of authentication and verification of \nindividual memory modules that were previously tied to a specific pair of EC and MED.  \nThe liabilities when using the SEL pattern are:  \n• As long as the securi ty logging is only handled in a closed local embedded platform, \nfurther system updates and configurations are not handled with the proposed pattern.  \n• Each device in the suggested embedded platform is handled as a separate unit, \nmeaning that each embedded c ontroller  comes with their own security module. This \nadvantage at flexibility comes also with a drawback, and that is the increase of the \ngeneral production cost.  \n• Many embedded devices today are limited in terms of the extension capabilities, i.e., \neither  not containing their own security modules or not providing additional \ninterfaces.  \n\n1.11. Known Uses  \n \n1.12. See Also  \nA pattern that is similar in design but different in intent and context would be the SECURITY \nLOGGER AND AUDITOR . It is focused on logging security -sens itive actions from different users. \nHence, this pattern offers a security solution in tying recorded information with the particular \nusers of a system on an architectural level. Another similar pattern would be the Secure Logger \nwhich is traditionally used  for capturing targeted application events [ 4]. It is an \nimplementation design pattern that can be applied on the software level in situations where \notherwise system constraints are of no concern and are not taken into the design \nconsideration . \n1.13. References  \n[1] Andrea, D. (2010).  Battery management systems for large lithium -ion battery packs . Artech \nhouse.  \n[2] Deng, J., Li, K., Laverty, D., Deng, W., & Xue, Y. (2014). Li -ion battery management system \nfor electric vehicles -a practical guide. In  Intelligent Computing in Smart Grid and Electrical \nVehicles  (pp. 32 -44). Springer, Berlin, Heidelberg.  \n[3] Xiong, R., Cao, J., Yu, Q., He, H., & Sun, F. (2017). Critical review on the battery state of \ncharge estimation methods for electric vehicles.  Ieee Access , 6, 1832-1843.  \n[4] Steel, C., & Nagappan, R. (2006).  Core Security Patterns: Best Practices and Strategies for J2EE, Web Services, and Identity Management . Pearson Education India.  \n1.14. Sources  \nBasic, F., Steger, C., & Kofler, R. (2021, July). Embedded Platform Patt erns for Distributed and \nSecure Logging. In  26th European Conference on Pattern Languages of Programs  (pp. 1 -9). \n"
        },
        {
            "title": "Third party-based authentication",
            "text": "2.1. Intent  \nTwo  parties  can establish a secure communication channel by using public key cryptography \nbased on certificates for authenticating each communication participant , by relying on a \ntrusted third party who proves the authenticity of each participant.  \n2.2. Example  \nOne example  could be that a company X is developing a server hosting a web -shop. If a \ncustomer wants to buy something from the shop, he needs to send his credit card information \nto the server. The customer is not interested in sending his credit card information in p lain and \nhence a secure channel has to be established. Further, the customer is not interested in \nstarting a symmetric key exchange process via a second secure channel ( i.e., a key shipment \nusing trusted couriers), because he wants to perform the operation  now and not after some \ndays when he finally received the symmetric key.  \n2.3. Context  \nA system wants to establish a secure channel with another party via an insecure channel. Both \ncommunication parties are not limited in terms of computational power or resource s (e.g.,  a \npersonal computer / smart phone communicates with a server ) but  may not know each other \nin advance. A MITM can eavesdrop or change every sent message package. Further the MITM \nis able to resent previously eavesdropped packages (replay attack).  \n2.4. Problem  \nSince both communication parties are not known to each other ( i.e., no shared secret \nknowledge, nor a known public key) a mechanism is required such that trust is gained. No \nsecret data shall be exposed to a third party listening or intercepting the  communication. No \npreviously recorded message package should trigger an unwanted action ( e.g.,  a payment \ntransaction).  \nThe following forces need to be considered:  \n• User experience: The security controls should not negatively influence the functional \nbehav ior (e.g.,  real-time capabilities) of the system.  \n• Computational complexity: Public key cryptography is more time consuming compared \nwith symmetric cryptography.  \n• Eavesdropping: Each sent communication package may be eavesdropped or replaced \nby a malicious  third party. 2.5. Solution  \nUse public key cryptography based on certificates for authenticating each communication \nparticipant (abbreviated as Alice and Bob in the following). After successful authentication, a \nsession key is generated to secure the further co mmunication.  \nThe solution of this problem is to have a trusted third party who proves the authenticity of \neach participant. This is usually called a Certificate Authority which proves the identity of the \ncommunication parties and signs their public keys .  \n2.6. Structure  \n \n2.7. Dynamics  \nThe principal  sequence of steps for certificate based secure channel establishment is \nillustrated in Figure 4 and described in the following:  \n1. Before a communication is possible, Alice and Bob need to request a certificate issued \nby a tr usted third party (CA). The CA proves the identity of Alice and Bob ( e.g.,  by \nverifying the passport) and issues the certificate ( i.e., signs the public key of Alice and \nBob).  \n2. To start the communication, Bob sends a message to Alice including a random numb er \nfor the authentication process. A time stamp should be incorporated to harden the \nsystem against replay attacks.  \n3. Alice answers the request with her certificate. Bob extracts the public key of Alice and \nverifies the certificate by using the public key o f the CA.  \n4. If the verification was successful, Bob sends his certificate to Alice such that she can \nverify the properness of Bob’s certificate and to retrieve his public key.  \n5. Until that point, no encryption is needed at all since the certificates are publ ic anyway. \nIn principle, these steps could have been performed by a malicious third party which \nhas Bob’s certificate. Thus, Bob sends the hash of all previous messages which is \nsigned with his private key so that Alice can prove that Bob has the correspon ding \nprivate key of the sent certificate. This is important since a malicious third party – \nwhich only owns the certificate – cannot compute the signature of the hash. As a \nresult, Alice will terminate the communication if she cannot verify the signature.  \n6. Both parties need to agree on a session key to encrypt all future messages. This can be \nachieved by using dedicated key derivation functions ( e.g.,  by using a Diffie -Hellman \nkey agreement where a symmetric session key is generated based on the used key -\npairs or by randomly generating a new key. This generated key has to be sent \nencrypted to Alice / Bob using their according public key. Usually,  symmetric session \nkeys are chosen due to performance reasons.  \nThe presented solution covers the case that Bob is authenticated to Alice. For some \napplications this may not be sufficient. To ensure MUTUAL  AUTHENTICATION , Bob has to send \na challenge to Alice. In the simple case, this can be achieved by repeating step 5 where Alice is \ncalculating the hash and Bob is ver ifying the signature of the message.  \nEach certificate has a specific date at which it gets automatically invalid. In some cases, it may \nhappen that the owner of the certificate or the CA want to revoke the certificate earlier ( i.e., \nthe private key was broken / leaked, it was improperly issued, etc.). Therefore, so called \nrevocation lists were introduced containing a list of invalid certificates. To ensure that such \ncertificates are not used, each communication participant needs to c onsult the CA to retrieve \nthis list. Thus, an online connection is necessary to regularly update these lists.  \n \nFigure 4:  Certificate based authentication  \n \n2.8. Implementation  \n \n2.9. Example Resolved  \n \n2.10. Consequences  \nThe benefits of the pattern are:  \n• Through the use of certificates, Alice and Bob can assure that they are talking to each \nother and not to a Man -In-The-Middle.  \n\n• There are open -source  libraries supporting such authentication processes ( e.g.,  \nOpenSSL)  \nThe li abilities are:  \n• The Certificates are based on public key cryptography which can be time -consuming \nwhen operated on small embedded systems.  \n• If the Man -In-The-Middle is cooperating with the Certificate issuer, a Man -In-The-\nMiddle attack cannot be detected /  prevented, since he is able to manipulate the \ncertificates of Alice and Bob . Such “hacks”  cannot be prevented since the CA deals as a \nroot of trust.  \n• Requires an online connection or a frequent update of revocation lists to ensure that \nno blacklisted cert ificate is accepted as valid.  \n2.11. Known Uses  \n• Secure Sockets Layer (SSL), Transport Layer Security (TLS) [ 1]. This system uses the \nprocess illustrated in Figure 4 using symmetric session keys.  \n• Secure key agreement algorithms like the extended Diffie -Hellman key  exchange [ 2]. \nThis process implements the presented pattern with a bi -directional challenge \nresponse protocol to ensure that Alice and Bob are the owner of the corresponding \nprivate keys.  \n2.12. See Also  \nThe ASYMMETRIC ENCRYPTION pattern is used multiple times i n the presented pattern: The \nsignature operation performed by Bob and / or Alice is an asymmetric encryption operation \nusing the private key and a specific message. During the session key agreement asymmetric \nencryption can be used to send the session key.   \nThe SYMMETRIC ENCRYPTION pattern can be used in case of symmetric session keys.  \nThis pattern uses the MUTUAL  AUTHENTICATION  pattern.  \n2.13. References  \n[1] Das, M. L., & Samdaria, N. (2014). On the security of SSL/TLS -enabled applications.  Applied \nComputing and informatics , 10(1-2), 68 -81. \n[2] Yooni, E. J., & Yoo, K. Y. (2010, June). A new elliptic curve diffie -hellman two -party key \nagreement protocol. In  2010 7th International Conference on Service Systems and Service \nManagement  (pp. 1 -4). IEEE.  \n2.14. Sources  \nSinnhofer, A. D., Oppermann, F. J., Potzmader, K., Orthacker, C., Steger, C., & Kreiner, C. (2016, \nJuly). Patterns to establish a secure communication channel. In Proceedings of the 21st \nEuropean Conference on Pattern Languages of Programs (pp. 1 -21). \n"
        },
        {
            "title": "Mutual Authentication",   
            "text": "3.1. Intent  \nIn a grid environment, parties may need to prove to each other that they are who they say \nthey are, before proceeding with their actual business. This is known as MUTUAL \nAUTHENTICATION and is accomplished by the parties excha nging their credentials.  \n3.2. Example  \nA user at site A requests to a simulation service to run a simulation at site B. The simulation \nmay access sensitive date on the user’s behalf. Before any simulation actions, the user and the \nsimulation service must first e stablish two -way trust between each other, since typically, these \ntwo sites are in different security domains.  \nIf we allowed the simulation service to serve any user anonymously, we run the risk that \nsimulations could be executed by users with no authoriza tion to access sensitive data at site B, \neither maliciously or by accident. Similarly, the user wants to first authenticate the simulation \nservice before entrusting it with her simulation request.  \n3.3. Context  \nA grid environment in which two parties need to est ablish mutual trust between each other. \nCREDENTIAL pattern is used as a precondition to identity the parties.  \n3.4. Problem  \nTwo parties must establish mutual trust between each other, before any further operations \ncan happen. Refer to the two parties as Alice and Bob. Alice requests a service from Bob, \nassuming she is authorized by Bob to do so. The initial mutual trust must be established. Then \nAlice is sure that she is communicating with Bob who can provide the service she is requesting, \nand Bob ensures  that it in fact is Alice attempting access and not a third party not authorized \nto the service.  \nOne solution would be for Bob and Alice to authenticate each other with a username and \npassword as an identity. But this would also require Alice and Bob to kn ow each other’s \npasswords prior to authentication, and somehow keep a copy of the secret password. This \ncopy leaves a security, because once an attacker obtains the passwords, they can steal the \nidentities of Alice and Bob. Thus, the more entities with who m a party communicates, the less \nsecure its identity. Another disadvantage of this solution is the overhead caused by managing \ncopies of the passwords. Therefore, a precondition of this pattern is CREDENTIAL . More \nspecifically, X.509 certificates from the public key infrastructure (PKI) can be used to \nimplement the CREDENTIAL pattern.  \nTo solve this problem, the following forces must be balanced:  \n• The solution should be easy to manage, but to gain this ease of use we cannot sacrifice \nprotection against ident ity thieves and eavesdroppers. Mutual Authentication• The identity of each entity should be persistent in all sessions initiated by it.  \n3.5. Solution  \nEach entity (verifier) verifies the other entity's (verified) identity by validating the encryption of \nthe verified with her public c ertificate. Based on public key technology, an entity holds a pair of \npublic/private keys. The public key is contained in the entity’s certificate and the private key is \nonly accessible to the entity. If a message is encrypted with a private key, only the \ncorresponding public key can decrypt it.  \nThe parties share a randomly generated message. At either side, the verified encrypts the \nmessage with its private key, and the verifier decrypts the encryption using the public key in \nthe certificate of the verifie d. If the decrypted message matches the random message on hand, \nthe verifier can authenticate the verified. The certificate signed by a certificate authority (CA) \nrepresents who the verified is. The CA is the trust anchor of the verifier. As long as the ve rifier \ntrusts the CA, it would trust the identity of the verified represented by her certificate in the \nauthentication.  \n3.6. Structure  \nFigure 5 below shows the structure of this pattern. Alice and Bob want to mutually \nauthenticate each other. Alice holds a cert ificate Cert A which identifies her. Cert A is signed by \ncertificate authority CA A. Bob also holds a certificate Cert B as his identity signed by certificate \nauthority CA B. Alice verifies Cert B to be able to trust Bob, based on her trust to CA B. Bob \nverifies Cert A to be able to trust Alice, also based on his trust to CA A. MUTUAL \nAUTHENTICATION is then established after the two -way trust.  \n \nFigure 5: Structure of the MUTUAL AUTHENTICATION pattern  \n\n3.7. Dynamics  \n \n3.8. Implementation  \n \n3.9. Example Resolved  \nThe user has a X.509 certificated issued and signed by a CA. So does the simulation. The user \nand the simulation can both verify each other’s certificate and mutual authenticate as \ndescribed above. Through the authenticatio n, the simulation ensures the user’s identity and \ncan further check if she is authorized to access the data. Meanwhile, the user is also sure the \nsimulation service is the one she is requesting.  \n3.10. Consequences  \nThe following benefits may be expected from appl ying this pattern:  \n• The implementation of public key cryptography makes the authentication reliable \nagainst adversaries.  \n• X.509 certificates are widely used in many organizations. The existing public key \nframeworks such as PKI have taken good care of the c ertificate issuing and \nmanagement work.  \n• X.509 certificates are distinct based on their Subject Name and/or serial number, and \nno two certificate holders can be authenticated as the same entity, so the certificates \nare persistent and uniform in all session s. Therefore, authentication and authorization \npolicies can be defined on them for granting access.  \n• No one can forge the certificates since the CA private key for signing them is only kept \nsecret for the CA.  \nThe following liabilities may arise from applyi ng this pattern:  \n• It is significantly more expensive to implement than a lightweight mechanism based on \npasswords.  \n• To authenticate an entity, the user must trust the CA that signs its certificate. This \n“cold start” problem can be solved by using a CA hier archy. A root CA signs the \ncertificates of all the involved CAs, so parties now only need to both trust the root CA. \nThere can also be several trusted root CAs.  \n• MUTUAL AUTHENTICATION is slower compared to one -side only authentication and \nanonymity.  \n3.11. Known Uses  \nMUTUAL AUTHENTICATION appears before grid computing emerges, so it is not limited to \ngrids. It is used on client/server applications where clients hold certificates as identities. In \nLarge Hadron Collider (LHC) Computing Grid (LCG) project [1], the au thentication layer is based \non Globus Grid Security Infrastructure (GSI). Each grid user (and grid service) is in possession of \nan X509 format certificate. Certificates are issued by a network of Certification Authorities (CA) \napproved by the project. LCG enables services to operate on behalf of the user (such as for \nbatch job execution when the user is not present, or for provisioning of data from one storage \nlocation to another), and MUTUAL AUTHENTICATION is required between the services and the \nuser befo re delegation relationships are established [2].  \n3.12. See Also  \nMUTUAL AUTHENTICATION refines Known Partner pattern. CREDENTIAL pattern is used to \nidentify the parties who want to mutual authenticate each other.  \n3.13. References  \n[1] LCG. (n.d.). homepage. LHC Computin g Grid Project. https://wlcg.web.cern.ch/LCG/   \n[2] Neilson, I. & LCG Deployment Group. (2004). CERN. Jisc. \nhttp://www.jisc.ac.uk/uploaded_documents/CERN_%20PositionPaper.doc   \n3.14. Source  \nLu, M., & Weiss, M. (2008). Patterns for grid security. In  Mini -PLoP at conference on object -\norien ted programming systems, languages, and applications, OOPSLA . \n"
        },
        {
            "title": "Password based key exchange",
            "text": "4.1. Intent  \nTwo  communication parties use a  share d secret password  that protect s randomly generated  \nsession key pairs which are then used to establish a secure channel . \n4.2. Example  \nOne example could be a server which is operated by multiple users and need to be accessible \nfrom anywhere at any time. This requires that the operators may access the server from their \nprivate devices (like computers or smart phones) or vi a shared public available infrastructure \n(like public access points or internet coffee shops).  \n4.3. Context  \nA system wants to establish a secure channel with another party via an insecure channel. The \nconnectivity of the device is limited such that it is not po ssible to securely load or store long \nprivate keys on the device ( i.e., a user needs to manually enter it).  \n4.4. Problem  \nA user needs to manually enter a password to start the communication. In a realistic scenario, \nsuch passwords are “short” and designed to be  easy to remember. Using only these passwords \nwould result in an insecure system since dictionary attacks / brute force attacks could be \nperformed by a MITM to break the password. Further the MITM is able to resent previously \neavesdropped packages (replay attack).  \nThe following forces need to be considered:  \n• Limited access: Symmetric key files, certificates or WEB OF TRUST are not suitable \nsince it is not possible to securely load / store a private key file on the device.  \n• User experience: The security controls should not negatively influence the functional \nbehavior  of the system.  \n• Eavesdropping: Each sent communication pack age may be eavesdropped or replaced \nby a malicious third party  \n4.5. Solution  \nBoth communication parties (abbreviated as Alice and Bob) need to share a secret password. \nThis password is used to protect randomly generated session key pairs which are used to \nfurth er secure the communication. \n 4.7. Dynamics  \nSince Alice or Bob wants to transmit high confidential data using a weak (easy to remember) \nsymmetric key they need to issue a password based key agreement process. Asymmetric \ncryptography has been proven in  that context [ 1,2,3 ]. Thus, Alice and Bob need to agree on a \nshared secret which is incorporated into the key agreement protocol such that the used public \nkey scheme is authenticated using this shared secret. The principal  sequence of steps is \ndisplayed i n Figure 6.  \n1. Before starting a secure communication, Bob is generating a new random key pair \n(Public Key: PB; Private Key: PprivB).  \n2. To start a communication, Bob sends a message to Alice containing the newly \ngenerated public key which is encrypted using the  shared secret password.  \n3. Alice receives the message and generates a new random key pair (Public Key: PA; \nPrivate Key: PprivA). The fact that Alice and Bob are both generating new key pairs is \nessential to increase the overall strength of the protocol. By doing so, it is getting more \ndifficult to achieve offline brute -force attacks (see [ 2]). \n4. Alice retrieves Bob’s public key PB by decrypting the received message with the shared \nsecret. Alice encrypts her generated public key PA with the retrieved public key  PB \n(abbreviated as C). Further, the resulting cryptogram is encrypted with the shared \nsecret password before sent to Bob.  \n5. Bob can retrieve PA by first decrypting the received message with the shared secret \nand by decrypting the result with his private ke y PprivB. After that, Alice and Bob are \nable to start a secure communication based on the generated key pairs. For large \namount of data,  it is advisable to start a session key agreement to establish a strong \nsymmetric key ( i.e., AES-256).  \n6. The next steps i llustrated in Figure 6 describes a basic challenge -response protocol to \nverify the validity of the generated cryptographic keys. This is done in most \ncryptographic protocols to ensure that Alice and Bob are able to decrypt messages \nwhich were encrypted wit h the according public key PA/PB.  \na. Bob generates a random number R1 which he sends encrypted with the \nretrieved public key PA to Alice.  \nb. Alice retrieves the generated random number R1 by decrypting the received \nmessage. She generates a new random number R2  which she concatenates \nwith R1. Alice uses the public key PB to encrypt the concatenated random \nnumbers and sends the cryptogram to Bob.  \nc. Bob decrypts the received message and verifies that R1 is part of the received \nmessage. Further he retrieves the rand om number R2 and sends it encrypted \nwith PA back to Alice.  \nd. Alice verifies the correctness of R2  \n7. Both parties need to agree on a session key to encrypt all future messages. This can be \nachieved by using dedicated key derivation functions ( e.g.,  by using a  Diffie -Hellman \nkey agreement where a symmetric session key is generated based on the used key -\npairs [ 4]) or by randomly generating a new key. This generated key has to be sent \nencrypted to Alice / Bob using their according public key. Usually,  symmetric s ession \nkeys are chosen due to performance reasons.  \nThe illustrated sequence used two times the shared secret password to encrypt a message \n(encryption of PB and C). In most cases, one of these encryption operations can or should be \nomitted. As stated in [ 2], the most obvious reason to skip one of the encryption operation is, \nthat the message which shall be encrypted has to be indistinguishable from a random number. \nOtherwise,  an attacker has knowledge about the principle structure of the plain text. Thus, a n \nattacker could perform more sophisticated attacks against the shared secret password to \nbreak it.  \nThe problem which remains is how to choose or how to establish the initial shared secret. This \nneeds to be done using a different channel which can either b e considered as secure, or the \nway the data is sent via this channel can be considered as being secure. For example, a \npassword -based  secret can be used which is sent to Bob in a secure way. This could be \nachieved via a key shipment split on multiple key s hares using trusted couriers (see [ 5,6,7] for \nrecommendations).  \n \nFigure 6: Shared secret authenticated public key establishment.  \n4.8. Implementation  \n \n4.9. Example Resolved  \n \n4.10. Consequences  \nThe benefits of the pattern are:  \n\n• Using a “weak” shared secret produces a good channel protection against a Man -In-\nThe-Middle attack since an attacker can only hack the system by brute -forcing the \nrandomly generated public key (which should be of reasonabl e length).  \n• I do not need a third party claiming the authenticity of a communication partner.  \nThe liabilities are:  \n• Establishing a shared secret without using certificate based public key cryptography is \nhard.  \n• Both parties need to agree on another channel  via which the shared secret is \nestablished which reduces the overall usability of this pattern.  \n4.11. Known Uses  \nUse-Cases are mainly found in the domain of password -authenticated key agreements like:  \n• Encrypted Key Exchange protocols (e.g. [ 1,2,3 ]). These are b ased on the process \nillustrated in Figure 6 but provides slightly adaptations for different public key schemes \n(like RSA, ECC). The reason for this is to reduce the complexity of the overall process \ndue to security properties of the different schemes.  \n• Dragonfly (see [ 8]). This protocol uses EC based cryptography in combination with a \npseudo -random key derivation function to diversify the shared secret at the beginning \nof each session.  \n4.12. See Also  \nThe presented pattern makes use of the ASYMMETRIC ENCRYPTION pattern in combination \nwith a secret knowledge in form of a password .  \nThe shared knowledge is required to ensure that Alice and Bob are who they claim to be by \nproofing their knowledge about the shared secret.  \nThe ASYMMETRIC ENCRYPTION  pattern is used to p rotect the messages sent between Alice \nand Bob to establish a secure channel. Further, it can be used for the session key agreement.  \nThe SYMMETRIC ENCRYPTION pattern can be used in case of symmetric session keys.  \n4.13. References  \n[1] Bellovin, S. M., & Merritt,  M. (1993).  U.S. Patent No. 5,241,599 . Washington, DC: U.S. \nPatent and Trademark Office.  \n[2] Bellovin, S. M., & Merritt, M. (1993, December). Augmented encrypted key exchange: A \npassword -based protocol secure against dictionary attacks and password file compromise. \nIn Proceedings of the 1st ACM Conference on Computer and Communications Security  (pp. 244 -\n250).  \n[3] Bellovin, S. M., & Merritt, M. J. (1995).  U.S. Patent No. 5,440,635 . Washington, DC: U.S. \nPatent and Trademark Office.  \n[4] Rescorla, E. (19 99). Diffie -hellman key agreement method.  \n[5] NIST. (2016).  Special Publication 800 -57-1: Recommendation for key management: Part 1: \nGeneral . Gaithersburg, MD, USA: National Institute of Standards and Technology, Technology \nAdministration.  \n[6] Industry, P.  C. (2016). Data Security Standard: Requirements and security assessment \nprocedures.  Version 3.2 , 1. \n[7] International Organization for Standardization (ISO). (2006 ). ISO/IEC 11770 -4: Information \nTechnology - Security Techniques - Key Management - Part 4: Mechanisms Based On Weak \nSecrets.  \n[8] Harkins, D., & Zorn, G. (2010).  Extensible authentication protocol (EAP) authentication using \nonly a password  (pp. 1 -40). RFC 5 931, August.  \n4.14. Sources  \nSinnhofer, A. D., Oppermann, F. J., Potzmader, K., Orthacker, C., Steger, C., & Kreiner, C. (2016, \nJuly). Patterns to establish a secure communication channel. In Proceedings of the 21st \nEuropean Conference on Pattern Languages of Prog rams (pp. 1 -21)."
        }


    ]
}