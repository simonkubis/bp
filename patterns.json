{
    "patterns": [
        {
            "title": "Secure Embedded Logging",
            "text": "1.1. Intent\nAnswering to the security needs by extending the data logging capabilities in the embedded\nplatforms by adding security modules and services. The proposed pattern can be used to add\nthe logging security features together with a design-focused logging solution.\n1.2. Example\nElectric vehicles contain specialized embedded platforms called Battery Management System\n(BMS), dedicated for control and management of battery cells used to power up the engine\nand other components [1,2]. Different derivations of BMS exist, with the modular and\ndistributed BMS being more common than the others. Each Battery pack contains several\ndedicated sensors alongside battery cells [1]. The battery packs are controlled through Battery\nCell Controllers (BCC), which are assigned to handle the immediate data control and\nthroughput of these individual packs. A central BMS receives individual battery packs data\nfrom the BCCs. This data ranges from the sensor data (e.g., temperature data) to the voltage\nand current of a particular cell. They are used to extract information like state of charge (SoC)\nor state of health (SoH) [3]. Based on the data received, BMS can also store and handle error\nevents.\nWhen a battery pack gets depleted, it needs to be replaced. The replaced battery pack can\noften still be used as an active component for some other appliances, e.g., power grids. Here,\nbattery packs are aimed to be shipped together with their assigned BCCs. In case the BCCs are\nto remain as part of the vehicle and its BMS, a design compromise needs to be established to\nenable the logged operational data to be shipped with the battery pack as well. Since BMS\nwould be mass-produced, a design needs to be made in the earlier phases of the development.\nIt is desirable to enable the porting of the stored memory units together with the battery\npacks as to be able to track the health of the used battery packs or for any additional data\npost-processing. It is of critical importance that only valid battery packs are being transported\nand that it is possible to authenticate the memory units used with the previous battery packs.\nThis constraint is essential to make sure that no malicious attacks through a modified memory\nunit are possible. Additionally, the data that is stored needs also to be secured. The reason for\nmaking it secure is to guard it against any potential malicious attacks or even faults that can\narise from oversights during service and maintenance. The constraint is still present to handle\nthese design steps in the initial development phase. This is done for the fact that the battery\npacks would be mass-produced. Any change that would otherwise be done later could\njeopardize the security of the battery packs and add an additional cost.\n1.3. Context\nAn embedded platform is being designed which uses local memory devices to handle the\nstorage of lifetime logging data. For the reasons of the cost and memory size limitations, as\nwell as not having, or having limited, access to a wide network, it is intended for the platform\nto rely on local solutions rather than remote services. Often, these types of systems are closed\nand protected under a specific group. It is critical that the stored data maintains its integrity\nand is only managed through authorized handlers in this environment. The embedded system\nwould consist of a selection of hardware modules, interfaces, and implemented software\nfunctions. The hardware modules are divided by their respective tasks and placement. These\nare usually tied to a specific architecture and their upgrade can be very difficult, or sometimes\nnot even possible. 1.4. Problem  \nHow to design an embedded platform that is able to securely handle, but also port and verify, \nlogging data from its source to a designated entity?  \nIn embedded platforms that use distributed module placement, log ging process and porting of \nthe logged data often introduce security risks. Porting would need to be done either by using a \nmanual external device or having a connection to a network, both of which might be difficult, \nand even not feasible, under the platf orm constraints. Additionally, changes introduced to the \nsystem on a physical layer may hamper security during the transfer of the saved data and \npresent a high level of porting complexity. Modules used would need to account for security \nfunctionality and have pre -defined elements that supplement them. These considerations \nresult in making it a very challenging and expensive task.  \nDifferent malicious attacks can be mounted aimed directly at the content of the logged data \nduring both the active logging peri od and during the offload transfer period. It is challenging to \nderive a definite list of threats, as these are usually use -case or application dependent . Here \nwe focus primarily on generic threats that are found in embedded logging systems. Specifically, \nwe consider the following main threats:  \n• Spying on the targeted process: If not properly secured, an attacker can derive \ninformation, and even knowledge, from the stored log data by a direct port access.  \n• Logged data tampering: Unauthorized change of the c urrent, or previously stored, log \ncontent. This includes active attacks on the communication points during the ongoing \nlogging process, but also direct tamper attacks on the devices.  \n• Counterfeited sources: Each logged data is tied to an affiliated monitor ed device that is \nalso supplied from a certified manufacturer. During the offload transfer period of the \ndevice, i.e., when the change of the targeted monitored device happens, the device \ncan be replaced with a counterfeited or a malicious one. A different  attack would be \nby using the same device but replacing the data inside it.  \nThe following forces apply to the possible solution:  \n• Streamlined HW/SW integration: Implementation of the hardware and software \nelements associated with the security functionalit y need to be easily replicated across \nmultiple devices and vendors.  \n• Production cost: Changes made to the hardware and software design of the embedded \nsystems can result in an increased manufacturing cost.  \n• Limited resources: The embedded system needs to b e able to execute all necessary \nfunctions under different constraints.  \n• Security - confidentiality and integrity: Necessary measures need to be taken which \nshould prevent the logged data to be tampered or spied on.  \n• Security - authenticity: The logged data  that is stored needs to be able to be properly \nidentified and verified that it comes from a valid source entity. This authenticity is also \nnecessary each time the data needs to be accessed during the active period, i.e., when \nthe data is retrieved for the  analytic or other operational purposes  \n1.5. Solution  \nEnsure that the monitored logged data will be securely protected through an integrated \nsecurity module relaying data to the memory module and authenticated by using necessary \nhardware and software critical c omponents embedded during the deployment phase.  \nWhen implementing a logging procedure as part of the constrained embedded platform, the \nsecurity requirement is achieved by integrating a Security Module (SM) as part of the EC. While \nadding the SM to indivi dual EC devices adds to the overall cost, it does make the system more \ndecentralized. Furthermore, this ensures that the security operations are distributed without \nheavily impacting the performance. EC device vendors could also not guarantee that the \nlogg ed data would be secured since the EC itself would not handle that constraint. Therefore, \nit is necessary to also couple the security operations as part of the EC to appropriately address \nthe security design and attest that the information stored will be p rotected.  \n1.6. Structure  \nFigure 1 depicts the design behind the solution and shows the recommended building blocks. \nThe following components are listed:  \n• Embedded Controller (EC): Contains necessary interfaces for the communication, main \ndriver logic, and the control bridge between the dat a that is to be stored and the \nsecurity driver.  \n• Logging Memory Unit (LMU): Dedicated device for storing the encrypted data; contains \nnecessary description data, encrypted security keys, and the encrypted data.  \n• Security Module (SM): Provides security oper ations; works as a security bridge \nbetween the EC and the LMU.  \n• Source Verification Device (SVD): Device tied to a particular LMU and used for the \nauthentication purpose; can contain necessary authentication data, i.e., private -public \nkey pair, and/or a ce rtificate. It is also generally seen as the device from which logging \nprocess data is retrieved (data source).  \n \nFigure 1: Design -based solution in task separation for handling security logging by providing secure operations and \ndevice authentication.  \nSoftware functions and associated security data would be handled by the SM itself. At the \nsame time, it would use the logic controller of the EC to drive the overall processing and data \npreparation when storing it as part of the loggin g. It is necessary to keep the SM cheap in \ndesign. As a minimum -security requirement when storing the logging data, we propose to use \nencryption and authentication for the stored data. These can either be achieved by using \nseparate security functions or ap plying a suite like Authenticated Encryption (AE) to handle \nthis process. The data integrity check (additional AE data or a separate operation) would be \nsaved in a separate memory block inside the LMU. These, however, do not need to be secured, \nbut they do  need to be checked by the EC from the SM each time a new LMU is authenticated. \nThey also need to be periodically updated from the SM after new data is written. The SM \nshould also offer the functionality of storing and handling the key data used by the sec urity \noperations. Additionally, an EC together with its SM could also provide a Key Derivation \nFunction (KDF). The basic principle of deriving and delivering the keys between the parties is \nleft to the designers. The keys are generally securely encrypted a nd stored in the LMU secure \nsection. The authentication operations can either be managed using symmetric -based \nauthentication, e.g., AES challenge/response mechanism or by using asymmetric \nauthentication, e.g., Public Key Infrastructure (PKI). The security  operations can be handled \nentirely through software or be hardware -derived, where the hardware operations usually \noffer better performance, e.g., hardware implementation of the Advanced Encryption \nStandard (AES). While we consider using the integrated sec urity engine through a dedicated \nSM as the most cost -effective solution, other dedicated hardware security components can \nalso be examined. These include Secure Elements (SE) and Trusted Platform Module (TPM). \nHowever, unlike the integrated secure engine, SE and TPM are more complex to incorporate \nand much more costly.  \n \n\n1.7. Dynamics  \nThe pattern is aimed at providing an affordable and secure solution when transporting and \nthen replacing an LMU.  \nThis process is depicted in Figure 2. Here, a user would receive the LMU together with the SVD \nfrom a previous socket. When integrating it into the new system, it might be necessary to \nverify this memory unit alongside the newly installed SVD, which has been formerly taken out \nfrom the older system. This is achi eved by using the previously explained security verification \nfunctions that the new EC, through its design with SM, would possess as well. The verification \nprocess needs to be successfully completed for the LMU to be further used, be it just for the \nanalyt ic or for continuing operations.  \n \n \nFigure 2: Sequence diagram describing the verification process during the porting of LMU and a SVD from a previous \nto a new embedded device platform.  \n \n1.8. Implementation  \n \n1.9. Example Resolved  \nBased on th e open design question presented in Section 1.2, we present a solution in form of a \nmodule extension. Here, security is applied to guarantee: (i) confidentiality - protecting \nnecessary system data by only providing data associated to the BMS operational cy cle, (ii) \nrepudiation – an action can be tied to the entity that caused it, and (iii) integrity – data has not \nbeen modified. The resulted block design is shown in Figure 3.  \n\nThe security functionality is controlled by an internal SM service engine. The SM  communicates \ndirectly with the EC and the memory interface.  \n \nFigure 3: Realized example based on the SECURE  EMBEDDED  LOGGING  pattern. Applied on a BCC of a BMS by \nextending its applicability for the secure logging process  \nWhen the need arises for a battery pack to be replaced, using this design, it is possible to also \nport the whole BCC easily  or just the memory module with the logged data, as indicated in the \npattern solution. Based on the implementation, the BMS would verify the newly added BCCs, \nwhile a BCC can independently run the verification operation on the connected battery pack \nand me mory module.  \n1.10. Consequences  \nThis section lists the benefits and liabilities found when applying the SEL architectural pattern \nbased on the Forces from Section 1.4. The benefits of the SEL pattern are:  \n• As the pattern suggests using a dedicated security modul e and predefined security \nfunctions per EC, the general production design can be applied on a larger scale.  \n• The pattern proposes the use of a dedicated SM that should allow, at a minimum, \nencryption,  and integrity check for handling the security of the st ored data.  \n• Additionally, the SM needs to allow for a method of authentication and verification of \nindividual memory modules that were previously tied to a specific pair of EC and MED.  \nThe liabilities when using the SEL pattern are:  \n• As long as the securi ty logging is only handled in a closed local embedded platform, \nfurther system updates and configurations are not handled with the proposed pattern.  \n• Each device in the suggested embedded platform is handled as a separate unit, \nmeaning that each embedded c ontroller  comes with their own security module. This \nadvantage at flexibility comes also with a drawback, and that is the increase of the \ngeneral production cost.  \n• Many embedded devices today are limited in terms of the extension capabilities, i.e., \neither  not containing their own security modules or not providing additional \ninterfaces.  \n\n1.11. Known Uses  \n \n1.12. See Also  \nA pattern that is similar in design but different in intent and context would be the SECURITY \nLOGGER AND AUDITOR . It is focused on logging security -sens itive actions from different users. \nHence, this pattern offers a security solution in tying recorded information with the particular \nusers of a system on an architectural level. Another similar pattern would be the Secure Logger \nwhich is traditionally used  for capturing targeted application events [ 4]. It is an \nimplementation design pattern that can be applied on the software level in situations where \notherwise system constraints are of no concern and are not taken into the design \nconsideration . \n1.13. References  \n[1] Andrea, D. (2010).  Battery management systems for large lithium -ion battery packs . Artech \nhouse.  \n[2] Deng, J., Li, K., Laverty, D., Deng, W., & Xue, Y. (2014). Li -ion battery management system \nfor electric vehicles -a practical guide. In  Intelligent Computing in Smart Grid and Electrical \nVehicles  (pp. 32 -44). Springer, Berlin, Heidelberg.  \n[3] Xiong, R., Cao, J., Yu, Q., He, H., & Sun, F. (2017). Critical review on the battery state of \ncharge estimation methods for electric vehicles.  Ieee Access , 6, 1832-1843.  \n[4] Steel, C., & Nagappan, R. (2006).  Core Security Patterns: Best Practices and Strategies for J2EE, Web Services, and Identity Management . Pearson Education India.  \n1.14. Sources  \nBasic, F., Steger, C., & Kofler, R. (2021, July). Embedded Platform Patt erns for Distributed and \nSecure Logging. In  26th European Conference on Pattern Languages of Programs  (pp. 1 -9). \n"
        },
        {
            "title": "Third party-based authentication",
            "text": "2.1. Intent  \nTwo  parties  can establish a secure communication channel by using public key cryptography \nbased on certificates for authenticating each communication participant , by relying on a \ntrusted third party who proves the authenticity of each participant.  \n2.2. Example  \nOne example  could be that a company X is developing a server hosting a web -shop. If a \ncustomer wants to buy something from the shop, he needs to send his credit card information \nto the server. The customer is not interested in sending his credit card information in p lain and \nhence a secure channel has to be established. Further, the customer is not interested in \nstarting a symmetric key exchange process via a second secure channel ( i.e., a key shipment \nusing trusted couriers), because he wants to perform the operation  now and not after some \ndays when he finally received the symmetric key.  \n2.3. Context  \nA system wants to establish a secure channel with another party via an insecure channel. Both \ncommunication parties are not limited in terms of computational power or resource s (e.g.,  a \npersonal computer / smart phone communicates with a server ) but  may not know each other \nin advance. A MITM can eavesdrop or change every sent message package. Further the MITM \nis able to resent previously eavesdropped packages (replay attack).  \n2.4. Problem  \nSince both communication parties are not known to each other ( i.e., no shared secret \nknowledge, nor a known public key) a mechanism is required such that trust is gained. No \nsecret data shall be exposed to a third party listening or intercepting the  communication. No \npreviously recorded message package should trigger an unwanted action ( e.g.,  a payment \ntransaction).  \nThe following forces need to be considered:  \n• User experience: The security controls should not negatively influence the functional \nbehav ior (e.g.,  real-time capabilities) of the system.  \n• Computational complexity: Public key cryptography is more time consuming compared \nwith symmetric cryptography.  \n• Eavesdropping: Each sent communication package may be eavesdropped or replaced \nby a malicious  third party. 2.5. Solution  \nUse public key cryptography based on certificates for authenticating each communication \nparticipant (abbreviated as Alice and Bob in the following). After successful authentication, a \nsession key is generated to secure the further co mmunication.  \nThe solution of this problem is to have a trusted third party who proves the authenticity of \neach participant. This is usually called a Certificate Authority which proves the identity of the \ncommunication parties and signs their public keys .  \n2.6. Structure  \n \n2.7. Dynamics  \nThe principal  sequence of steps for certificate based secure channel establishment is \nillustrated in Figure 4 and described in the following:  \n1. Before a communication is possible, Alice and Bob need to request a certificate issued \nby a tr usted third party (CA). The CA proves the identity of Alice and Bob ( e.g.,  by \nverifying the passport) and issues the certificate ( i.e., signs the public key of Alice and \nBob).  \n2. To start the communication, Bob sends a message to Alice including a random numb er \nfor the authentication process. A time stamp should be incorporated to harden the \nsystem against replay attacks.  \n3. Alice answers the request with her certificate. Bob extracts the public key of Alice and \nverifies the certificate by using the public key o f the CA.  \n4. If the verification was successful, Bob sends his certificate to Alice such that she can \nverify the properness of Bob’s certificate and to retrieve his public key.  \n5. Until that point, no encryption is needed at all since the certificates are publ ic anyway. \nIn principle, these steps could have been performed by a malicious third party which \nhas Bob’s certificate. Thus, Bob sends the hash of all previous messages which is \nsigned with his private key so that Alice can prove that Bob has the correspon ding \nprivate key of the sent certificate. This is important since a malicious third party – \nwhich only owns the certificate – cannot compute the signature of the hash. As a \nresult, Alice will terminate the communication if she cannot verify the signature.  \n6. Both parties need to agree on a session key to encrypt all future messages. This can be \nachieved by using dedicated key derivation functions ( e.g.,  by using a Diffie -Hellman \nkey agreement where a symmetric session key is generated based on the used key -\npairs or by randomly generating a new key. This generated key has to be sent \nencrypted to Alice / Bob using their according public key. Usually,  symmetric session \nkeys are chosen due to performance reasons.  \nThe presented solution covers the case that Bob is authenticated to Alice. For some \napplications this may not be sufficient. To ensure MUTUAL  AUTHENTICATION , Bob has to send \na challenge to Alice. In the simple case, this can be achieved by repeating step 5 where Alice is \ncalculating the hash and Bob is ver ifying the signature of the message.  \nEach certificate has a specific date at which it gets automatically invalid. In some cases, it may \nhappen that the owner of the certificate or the CA want to revoke the certificate earlier ( i.e., \nthe private key was broken / leaked, it was improperly issued, etc.). Therefore, so called \nrevocation lists were introduced containing a list of invalid certificates. To ensure that such \ncertificates are not used, each communication participant needs to c onsult the CA to retrieve \nthis list. Thus, an online connection is necessary to regularly update these lists.  \n \nFigure 4:  Certificate based authentication  \n \n2.8. Implementation  \n \n2.9. Example Resolved  \n \n2.10. Consequences  \nThe benefits of the pattern are:  \n• Through the use of certificates, Alice and Bob can assure that they are talking to each \nother and not to a Man -In-The-Middle.  \n\n• There are open -source  libraries supporting such authentication processes ( e.g.,  \nOpenSSL)  \nThe li abilities are:  \n• The Certificates are based on public key cryptography which can be time -consuming \nwhen operated on small embedded systems.  \n• If the Man -In-The-Middle is cooperating with the Certificate issuer, a Man -In-The-\nMiddle attack cannot be detected /  prevented, since he is able to manipulate the \ncertificates of Alice and Bob . Such “hacks”  cannot be prevented since the CA deals as a \nroot of trust.  \n• Requires an online connection or a frequent update of revocation lists to ensure that \nno blacklisted cert ificate is accepted as valid.  \n2.11. Known Uses  \n• Secure Sockets Layer (SSL), Transport Layer Security (TLS) [ 1]. This system uses the \nprocess illustrated in Figure 4 using symmetric session keys.  \n• Secure key agreement algorithms like the extended Diffie -Hellman key  exchange [ 2]. \nThis process implements the presented pattern with a bi -directional challenge \nresponse protocol to ensure that Alice and Bob are the owner of the corresponding \nprivate keys.  \n2.12. See Also  \nThe ASYMMETRIC ENCRYPTION pattern is used multiple times i n the presented pattern: The \nsignature operation performed by Bob and / or Alice is an asymmetric encryption operation \nusing the private key and a specific message. During the session key agreement asymmetric \nencryption can be used to send the session key.   \nThe SYMMETRIC ENCRYPTION pattern can be used in case of symmetric session keys.  \nThis pattern uses the MUTUAL  AUTHENTICATION  pattern.  \n2.13. References  \n[1] Das, M. L., & Samdaria, N. (2014). On the security of SSL/TLS -enabled applications.  Applied \nComputing and informatics , 10(1-2), 68 -81. \n[2] Yooni, E. J., & Yoo, K. Y. (2010, June). A new elliptic curve diffie -hellman two -party key \nagreement protocol. In  2010 7th International Conference on Service Systems and Service \nManagement  (pp. 1 -4). IEEE.  \n2.14. Sources  \nSinnhofer, A. D., Oppermann, F. J., Potzmader, K., Orthacker, C., Steger, C., & Kreiner, C. (2016, \nJuly). Patterns to establish a secure communication channel. In Proceedings of the 21st \nEuropean Conference on Pattern Languages of Programs (pp. 1 -21). \n"
        },
        {
            "title": "Mutual Authentication",   
            "text": "3.1. Intent  \nIn a grid environment, parties may need to prove to each other that they are who they say \nthey are, before proceeding with their actual business. This is known as MUTUAL \nAUTHENTICATION and is accomplished by the parties excha nging their credentials.  \n3.2. Example  \nA user at site A requests to a simulation service to run a simulation at site B. The simulation \nmay access sensitive date on the user’s behalf. Before any simulation actions, the user and the \nsimulation service must first e stablish two -way trust between each other, since typically, these \ntwo sites are in different security domains.  \nIf we allowed the simulation service to serve any user anonymously, we run the risk that \nsimulations could be executed by users with no authoriza tion to access sensitive data at site B, \neither maliciously or by accident. Similarly, the user wants to first authenticate the simulation \nservice before entrusting it with her simulation request.  \n3.3. Context  \nA grid environment in which two parties need to est ablish mutual trust between each other. \nCREDENTIAL pattern is used as a precondition to identity the parties.  \n3.4. Problem  \nTwo parties must establish mutual trust between each other, before any further operations \ncan happen. Refer to the two parties as Alice and Bob. Alice requests a service from Bob, \nassuming she is authorized by Bob to do so. The initial mutual trust must be established. Then \nAlice is sure that she is communicating with Bob who can provide the service she is requesting, \nand Bob ensures  that it in fact is Alice attempting access and not a third party not authorized \nto the service.  \nOne solution would be for Bob and Alice to authenticate each other with a username and \npassword as an identity. But this would also require Alice and Bob to kn ow each other’s \npasswords prior to authentication, and somehow keep a copy of the secret password. This \ncopy leaves a security, because once an attacker obtains the passwords, they can steal the \nidentities of Alice and Bob. Thus, the more entities with who m a party communicates, the less \nsecure its identity. Another disadvantage of this solution is the overhead caused by managing \ncopies of the passwords. Therefore, a precondition of this pattern is CREDENTIAL . More \nspecifically, X.509 certificates from the public key infrastructure (PKI) can be used to \nimplement the CREDENTIAL pattern.  \nTo solve this problem, the following forces must be balanced:  \n• The solution should be easy to manage, but to gain this ease of use we cannot sacrifice \nprotection against ident ity thieves and eavesdroppers. Mutual Authentication• The identity of each entity should be persistent in all sessions initiated by it.  \n3.5. Solution  \nEach entity (verifier) verifies the other entity's (verified) identity by validating the encryption of \nthe verified with her public c ertificate. Based on public key technology, an entity holds a pair of \npublic/private keys. The public key is contained in the entity’s certificate and the private key is \nonly accessible to the entity. If a message is encrypted with a private key, only the \ncorresponding public key can decrypt it.  \nThe parties share a randomly generated message. At either side, the verified encrypts the \nmessage with its private key, and the verifier decrypts the encryption using the public key in \nthe certificate of the verifie d. If the decrypted message matches the random message on hand, \nthe verifier can authenticate the verified. The certificate signed by a certificate authority (CA) \nrepresents who the verified is. The CA is the trust anchor of the verifier. As long as the ve rifier \ntrusts the CA, it would trust the identity of the verified represented by her certificate in the \nauthentication.  \n3.6. Structure  \nFigure 5 below shows the structure of this pattern. Alice and Bob want to mutually \nauthenticate each other. Alice holds a cert ificate Cert A which identifies her. Cert A is signed by \ncertificate authority CA A. Bob also holds a certificate Cert B as his identity signed by certificate \nauthority CA B. Alice verifies Cert B to be able to trust Bob, based on her trust to CA B. Bob \nverifies Cert A to be able to trust Alice, also based on his trust to CA A. MUTUAL \nAUTHENTICATION is then established after the two -way trust.  \n \nFigure 5: Structure of the MUTUAL AUTHENTICATION pattern  \n\n3.7. Dynamics  \n \n3.8. Implementation  \n \n3.9. Example Resolved  \nThe user has a X.509 certificated issued and signed by a CA. So does the simulation. The user \nand the simulation can both verify each other’s certificate and mutual authenticate as \ndescribed above. Through the authenticatio n, the simulation ensures the user’s identity and \ncan further check if she is authorized to access the data. Meanwhile, the user is also sure the \nsimulation service is the one she is requesting.  \n3.10. Consequences  \nThe following benefits may be expected from appl ying this pattern:  \n• The implementation of public key cryptography makes the authentication reliable \nagainst adversaries.  \n• X.509 certificates are widely used in many organizations. The existing public key \nframeworks such as PKI have taken good care of the c ertificate issuing and \nmanagement work.  \n• X.509 certificates are distinct based on their Subject Name and/or serial number, and \nno two certificate holders can be authenticated as the same entity, so the certificates \nare persistent and uniform in all session s. Therefore, authentication and authorization \npolicies can be defined on them for granting access.  \n• No one can forge the certificates since the CA private key for signing them is only kept \nsecret for the CA.  \nThe following liabilities may arise from applyi ng this pattern:  \n• It is significantly more expensive to implement than a lightweight mechanism based on \npasswords.  \n• To authenticate an entity, the user must trust the CA that signs its certificate. This \n“cold start” problem can be solved by using a CA hier archy. A root CA signs the \ncertificates of all the involved CAs, so parties now only need to both trust the root CA. \nThere can also be several trusted root CAs.  \n• MUTUAL AUTHENTICATION is slower compared to one -side only authentication and \nanonymity.  \n3.11. Known Uses  \nMUTUAL AUTHENTICATION appears before grid computing emerges, so it is not limited to \ngrids. It is used on client/server applications where clients hold certificates as identities. In \nLarge Hadron Collider (LHC) Computing Grid (LCG) project [1], the au thentication layer is based \non Globus Grid Security Infrastructure (GSI). Each grid user (and grid service) is in possession of \nan X509 format certificate. Certificates are issued by a network of Certification Authorities (CA) \napproved by the project. LCG enables services to operate on behalf of the user (such as for \nbatch job execution when the user is not present, or for provisioning of data from one storage \nlocation to another), and MUTUAL AUTHENTICATION is required between the services and the \nuser befo re delegation relationships are established [2].  \n3.12. See Also  \nMUTUAL AUTHENTICATION refines Known Partner pattern. CREDENTIAL pattern is used to \nidentify the parties who want to mutual authenticate each other.  \n3.13. References  \n[1] LCG. (n.d.). homepage. LHC Computin g Grid Project. https://wlcg.web.cern.ch/LCG/   \n[2] Neilson, I. & LCG Deployment Group. (2004). CERN. Jisc. \nhttp://www.jisc.ac.uk/uploaded_documents/CERN_%20PositionPaper.doc   \n3.14. Source  \nLu, M., & Weiss, M. (2008). Patterns for grid security. In  Mini -PLoP at conference on object -\norien ted programming systems, languages, and applications, OOPSLA . \n"
        },
        {
            "title": "Password based key exchange",
            "text": "4.1. Intent  \nTwo  communication parties use a  share d secret password  that protect s randomly generated  \nsession key pairs which are then used to establish a secure channel . \n4.2. Example  \nOne example could be a server which is operated by multiple users and need to be accessible \nfrom anywhere at any time. This requires that the operators may access the server from their \nprivate devices (like computers or smart phones) or vi a shared public available infrastructure \n(like public access points or internet coffee shops).  \n4.3. Context  \nA system wants to establish a secure channel with another party via an insecure channel. The \nconnectivity of the device is limited such that it is not po ssible to securely load or store long \nprivate keys on the device ( i.e., a user needs to manually enter it).  \n4.4. Problem  \nA user needs to manually enter a password to start the communication. In a realistic scenario, \nsuch passwords are “short” and designed to be  easy to remember. Using only these passwords \nwould result in an insecure system since dictionary attacks / brute force attacks could be \nperformed by a MITM to break the password. Further the MITM is able to resent previously \neavesdropped packages (replay attack).  \nThe following forces need to be considered:  \n• Limited access: Symmetric key files, certificates or WEB OF TRUST are not suitable \nsince it is not possible to securely load / store a private key file on the device.  \n• User experience: The security controls should not negatively influence the functional \nbehavior  of the system.  \n• Eavesdropping: Each sent communication pack age may be eavesdropped or replaced \nby a malicious third party  \n4.5. Solution  \nBoth communication parties (abbreviated as Alice and Bob) need to share a secret password. \nThis password is used to protect randomly generated session key pairs which are used to \nfurth er secure the communication. \n 4.7. Dynamics  \nSince Alice or Bob wants to transmit high confidential data using a weak (easy to remember) \nsymmetric key they need to issue a password based key agreement process. Asymmetric \ncryptography has been proven in  that context [ 1,2,3 ]. Thus, Alice and Bob need to agree on a \nshared secret which is incorporated into the key agreement protocol such that the used public \nkey scheme is authenticated using this shared secret. The principal  sequence of steps is \ndisplayed i n Figure 6.  \n1. Before starting a secure communication, Bob is generating a new random key pair \n(Public Key: PB; Private Key: PprivB).  \n2. To start a communication, Bob sends a message to Alice containing the newly \ngenerated public key which is encrypted using the  shared secret password.  \n3. Alice receives the message and generates a new random key pair (Public Key: PA; \nPrivate Key: PprivA). The fact that Alice and Bob are both generating new key pairs is \nessential to increase the overall strength of the protocol. By doing so, it is getting more \ndifficult to achieve offline brute -force attacks (see [ 2]). \n4. Alice retrieves Bob’s public key PB by decrypting the received message with the shared \nsecret. Alice encrypts her generated public key PA with the retrieved public key  PB \n(abbreviated as C). Further, the resulting cryptogram is encrypted with the shared \nsecret password before sent to Bob.  \n5. Bob can retrieve PA by first decrypting the received message with the shared secret \nand by decrypting the result with his private ke y PprivB. After that, Alice and Bob are \nable to start a secure communication based on the generated key pairs. For large \namount of data,  it is advisable to start a session key agreement to establish a strong \nsymmetric key ( i.e., AES-256).  \n6. The next steps i llustrated in Figure 6 describes a basic challenge -response protocol to \nverify the validity of the generated cryptographic keys. This is done in most \ncryptographic protocols to ensure that Alice and Bob are able to decrypt messages \nwhich were encrypted wit h the according public key PA/PB.  \na. Bob generates a random number R1 which he sends encrypted with the \nretrieved public key PA to Alice.  \nb. Alice retrieves the generated random number R1 by decrypting the received \nmessage. She generates a new random number R2  which she concatenates \nwith R1. Alice uses the public key PB to encrypt the concatenated random \nnumbers and sends the cryptogram to Bob.  \nc. Bob decrypts the received message and verifies that R1 is part of the received \nmessage. Further he retrieves the rand om number R2 and sends it encrypted \nwith PA back to Alice.  \nd. Alice verifies the correctness of R2  \n7. Both parties need to agree on a session key to encrypt all future messages. This can be \nachieved by using dedicated key derivation functions ( e.g.,  by using a  Diffie -Hellman \nkey agreement where a symmetric session key is generated based on the used key -\npairs [ 4]) or by randomly generating a new key. This generated key has to be sent \nencrypted to Alice / Bob using their according public key. Usually,  symmetric s ession \nkeys are chosen due to performance reasons.  \nThe illustrated sequence used two times the shared secret password to encrypt a message \n(encryption of PB and C). In most cases, one of these encryption operations can or should be \nomitted. As stated in [ 2], the most obvious reason to skip one of the encryption operation is, \nthat the message which shall be encrypted has to be indistinguishable from a random number. \nOtherwise,  an attacker has knowledge about the principle structure of the plain text. Thus, a n \nattacker could perform more sophisticated attacks against the shared secret password to \nbreak it.  \nThe problem which remains is how to choose or how to establish the initial shared secret. This \nneeds to be done using a different channel which can either b e considered as secure, or the \nway the data is sent via this channel can be considered as being secure. For example, a \npassword -based  secret can be used which is sent to Bob in a secure way. This could be \nachieved via a key shipment split on multiple key s hares using trusted couriers (see [ 5,6,7] for \nrecommendations).  \n \nFigure 6: Shared secret authenticated public key establishment.  \n4.8. Implementation  \n \n4.9. Example Resolved  \n \n4.10. Consequences  \nThe benefits of the pattern are:  \n\n• Using a “weak” shared secret produces a good channel protection against a Man -In-\nThe-Middle attack since an attacker can only hack the system by brute -forcing the \nrandomly generated public key (which should be of reasonabl e length).  \n• I do not need a third party claiming the authenticity of a communication partner.  \nThe liabilities are:  \n• Establishing a shared secret without using certificate based public key cryptography is \nhard.  \n• Both parties need to agree on another channel  via which the shared secret is \nestablished which reduces the overall usability of this pattern.  \n4.11. Known Uses  \nUse-Cases are mainly found in the domain of password -authenticated key agreements like:  \n• Encrypted Key Exchange protocols (e.g. [ 1,2,3 ]). These are b ased on the process \nillustrated in Figure 6 but provides slightly adaptations for different public key schemes \n(like RSA, ECC). The reason for this is to reduce the complexity of the overall process \ndue to security properties of the different schemes.  \n• Dragonfly (see [ 8]). This protocol uses EC based cryptography in combination with a \npseudo -random key derivation function to diversify the shared secret at the beginning \nof each session.  \n4.12. See Also  \nThe presented pattern makes use of the ASYMMETRIC ENCRYPTION pattern in combination \nwith a secret knowledge in form of a password .  \nThe shared knowledge is required to ensure that Alice and Bob are who they claim to be by \nproofing their knowledge about the shared secret.  \nThe ASYMMETRIC ENCRYPTION  pattern is used to p rotect the messages sent between Alice \nand Bob to establish a secure channel. Further, it can be used for the session key agreement.  \nThe SYMMETRIC ENCRYPTION pattern can be used in case of symmetric session keys.  \n4.13. References  \n[1] Bellovin, S. M., & Merritt,  M. (1993).  U.S. Patent No. 5,241,599 . Washington, DC: U.S. \nPatent and Trademark Office.  \n[2] Bellovin, S. M., & Merritt, M. (1993, December). Augmented encrypted key exchange: A \npassword -based protocol secure against dictionary attacks and password file compromise. \nIn Proceedings of the 1st ACM Conference on Computer and Communications Security  (pp. 244 -\n250).  \n[3] Bellovin, S. M., & Merritt, M. J. (1995).  U.S. Patent No. 5,440,635 . Washington, DC: U.S. \nPatent and Trademark Office.  \n[4] Rescorla, E. (19 99). Diffie -hellman key agreement method.  \n[5] NIST. (2016).  Special Publication 800 -57-1: Recommendation for key management: Part 1: \nGeneral . Gaithersburg, MD, USA: National Institute of Standards and Technology, Technology \nAdministration.  \n[6] Industry, P.  C. (2016). Data Security Standard: Requirements and security assessment \nprocedures.  Version 3.2 , 1. \n[7] International Organization for Standardization (ISO). (2006 ). ISO/IEC 11770 -4: Information \nTechnology - Security Techniques - Key Management - Part 4: Mechanisms Based On Weak \nSecrets.  \n[8] Harkins, D., & Zorn, G. (2010).  Extensible authentication protocol (EAP) authentication using \nonly a password  (pp. 1 -40). RFC 5 931, August.  \n4.14. Sources  \nSinnhofer, A. D., Oppermann, F. J., Potzmader, K., Orthacker, C., Steger, C., & Kreiner, C. (2016, \nJuly). Patterns to establish a secure communication channel. In Proceedings of the 21st \nEuropean Conference on Pattern Languages of Prog rams (pp. 1 -21)."
        },
        {
            "title":"Asymmetric Encryption",
            "text":"51.1. Intent ASYMMETRIC ENCRYPTION provides message confidentiality by keeping information secret in such a way that it can only be understood by intended recipients who have the access to the valid key. In ASYMMETRIC ENCRYPTION, a public/private key pair is used for encryption and decryption respectively. 51.2. Example Alice wants to send a personal message to Bob. They have not met each other to agree upon a shared key. Alice wants to keep the message secret, since it contains personal information. Eve can intercept Alice’s messages and may try to obtain the confidential information. 51.3. Context Applications that exchange sensitive information over insecure networks. 51.4. Problem Applications that communicate with external applications interchange messages that may contain sensitive information. These messages can be intercepted and read by imposters during transmission. How can we send sensitive information securely over insecure channels? The solution to this problem must resolve the following forces: • Confidentiality. Messages may be captured while they are in transit, so we need to prevent unauthorized users from reading them by hiding the information the message contains. Hiding information also makes replaying of messages by an attacker harder to perform. • Reception. The hidden information should be revealed conveniently to the receiver. • Protocol. We need to apply the solution properly, or it will not be able to withstand attacks (there are several ways to attack a method of hiding information). • Performance. The time to hide and recover the message should be acceptable. • Key distribution. Two parties may want to communicate to each other, but they have not agreed on a shared key: we need a way to send messages without establishing a common key. 51.5. Solution Apply mathematical functions to a message to make it unreadable to those that do not have a valid key. This approach uses a key pair: private and public key. The sender encrypts (E) the message (M) using the receiver’s public key (PuK), which is accessible by anyone. The result of this process is cipher text (C): C = EPuk(M). On the other side, the receiver decrypts (D) the cipher text (C) using their private key (PrK) to recover the plain message (M): M = DPrk(C). 51.6. Structure Figure 107 shows the class diagram for the ASYMMETRIC ENCRYPTION pattern. A Principal may be a user or an organization that is responsible for sending or receiving messages. The principal may have the roles of Sender or Receiver. A Sender may send a Message and/or an EncryptedMessage to a Receiver with which it shares a secret key. A Principal has one or more KeyPairs that are composed of a private key, kept secret by its owner, and a public key which is publicly published. PublicKeyRepository is a repository that contains a list of public keys where users can register and/or access public keys. These two keys are mathematically related, so while one encrypts, the other decrypts. However, it is not feasible to deduce a private key from its corresponding public key. The Encryptor creates the EncryptedMessage that contain the cipher text using the public key of the Receiver provided by the sender, while the Decryptor deciphers the encrypted data into its original form using its private key. Both the Encryptor and Decryptor use the same Algorithm to encipher and decipher a message. 51.7. Dynamics We describe the dynamic aspects of the ASYMMETRIC ENCRYPTION pattern using sequence diagrams for the following use cases: ‘Encrypt a message’ and ‘Decrypt a message’. Use Case: Encrypt a Message – Summary: A Sender wants to encrypt a message. Actors: A Sender. Precondition: The Sender has access to the Receiver’s public key. Both Sender and Receiver have access to a repository of algorithms. The message has already been created by the Sender. Description: 1. A Sender sends the message, the Receiver’s public key, and the algorithm identifier to the Encryptor. 2. The Encryptor ciphers the message using the algorithm specified by the Sender. 3. The Encryptor creates the EncryptedMessage that includes the cipher text. Postcondition: The message has been encrypted and sent to the Sender. Use Case: Decrypt an Encrypted Message – Summary: A Receiver wants to decrypt an encrypted message from a Sender. Actors: A Receiver. Precondition: Both the Sender and Receiver have access to a repository of algorithms. Description: 1. A Receiver sends the encrypted message and their private key to the Decryptor. 2. The Decryptor deciphers the encrypted message using the Receiver’s public key. 3. The Decryptor creates the Message that contains the plain text obtained from the previous step. 4. The Decryptor sends the plain text Message to the receiver. Alternate Flow: If the key used in step 2 is not mathematically related to the key used for encryption, the decryption process fails. Postcondition: The encrypted message has been deciphered and delivered to the Receiver. 51.8. Implementation • Use the Strategy pattern to select different encryption algorithms. • The designer should choose well-known algorithms such as RSA. • Encryption can be implemented in different applications, such as in e-mail communication, distribution of documents over the Internet, or web services. In these applications we are able to encrypt an entire document. However, in web services we can encrypt parts of a message. • Both the sender and the receiver have to previously agree what cryptographic algorithms they support. • A good key pair generator is very important. It should generate key pairs for which the private key cannot be deduced from the public key. 51.9. Example Resolved Alice now can look up Bob’s public key and encrypt the message using this key. Since Bob keeps his private key secret, he is the only one who can decrypt Alice’s message. Eve cannot understand the encrypted data since Eve does not have access to Bob’s private key. 51.10. Consequences The asymmetric encryption pattern offers the following benefits: • Asymmetric encryption does not require a secret key to be shared among all the participants. Anyone can look up the public key in the repository and send messages to the owner of the public key. • Only recipients that possess the corresponding private key can make the encrypted message readable again. • The strength of a cryptosystem is based on the secrecy of a long key. The cryptographic algorithms are known to the public, so the private key should be kept protected from unauthorized users. • It is possible to select from several encryption algorithms the one suitable for the application’s needs. • Encryption algorithms that take an acceptable time to encrypt messages exist. The pattern also has the following potential liabilities: • Cryptography operations are computationally intensive and may affect the performance of the application. Asymmetric encryption is slower than SYMMETRIC ENCRYPTION. It is best to use a combination of both algorithms: asymmetric encryption for key distribution, and SYMMETRIC ENCRYPTION for message exchange. • Encryption does not provide data integrity. The encrypted data can be modified by an attacker: other means, such as hashing, are needed to verify that a message has not been changed. • Encryption does not prevent a replay attack, because an encrypted message can be captured and resent without being decrypted. It is recommended to use another security mechanism, such as timestamps or Nonces, to prevent this attack. • This pattern assumes that a public key belongs to the person who they claim to be. How can we know that this person is not impersonating another? To confirm that someone is who they say they are, we can use certificates issued by a certification authority (CA). If the CA is not trustworthy, we may lose security. 51.11. Known Uses ASYMMETRIC ENCRYPTION has been widely used in different products. • GNuPG is free software that secures data from eavesdroppers. • Java Cryptographic Extension supports a variety of algorithms, including asymmetric encryption. • The .NET framework provides several classes to perform asymmetric encryption and decryption. • XML Encryption is one of the foundation web services security standards that defines the structure and process of encryption for XML messages. This standard supports both types of encryption: symmetric and asymmetric encryption. • Pretty Good Privacy (PGP) uses asymmetric encryption and decryption as one of its process to secure e-mail communication. 51.12. See Also • The SECURE CHANNELS pattern supports the encryption/decryption of data. This pattern describes encryption in more general terms: it does not distinguish between asymmetric and symmetric encryption. • The Strategy pattern describes how to separate the implementation of related algorithms from the selection of one of them. This pattern can be used to select an encryption algorithm dynamically. • Predicate-based encryption is a family of public key encryption schemes; patterns for them are described in [8]. 51.13. References [1] Gamma, E., Helm, R., Johnson, R., Johnson, R. E., & Vlissides, J. (1995). Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH. [2] Rivest, R. L., Shamir, A., & Adleman, L. M. (2019). A method for obtaining digital signatures and public key cryptosystems. In Secure communications and asymmetric cryptosystems (pp. 217-239). Routledge. [3] GnuPG. (n.d.). The GNU Privacy Guard. from http://www.gnupg.org/ [4] Sun Microsystems Inc. (n.d.). Java Cryptography Extension (JCE). From http://java.sun.com/j2se/1.4.2/docs/guide/security/jce/JCERefGuide.html [5] Microsoft Corporation. (2007, November). .NET Framework Class Library. from http://msdn.microsoftwarecom/enus/library/ms229335.aspx [6] W3C. (2002, December 10). XML Encryption Syntax and Processing. From http://www.w3.org/TR/xmlenc-core/ [7] Wikipedia contributors. (n.d.). Pretty Good Privacy. Wikipedia. from https://en.wikipedia.org/wiki/Pretty_Good_Privacy [8] de Muijnck-Hughes, J., & Duncan, I. (2012, June). Thinking towards a pattern language for predicate based encryption crypto-systems. In 2012 IEEE Sixth International Conference on Software Security and Reliability Companion (pp. 27-32). IEEE. 51.14. Source Fernandez-Buglioni, E. (2013). Security patterns in practice: designing secure architectures using software patterns. John Wiley & Sons."
        },
        {
            "title":"Security Logger and Auditor",
            "text": "73.1. Intent The SECURITY LOGGER AND AUDITOR pattern describes how to keep track of users’ actions in order to determine who did what and when. It logs all security-sensitive actions performed by users and provides controlled access to records for audit purposes. 73.2. Example A hospital uses RBAC to define the rights of its employees. For example, doctors and nurses can read and write medical records and related patient information (lab tests and medicines). When a famous patient came to the hospital, one of the doctors, who was not treating him, read his medical record and leaked this information to the press. When the leak was discovered, there was no way to find out which doctor had accessed the patient’s records. 73.3. Context Any system that handles sensitive data, in which it is necessary to keep a record of access to data. 73.4. Problem How can we keep track of users’ actions in order to determine who did what and when? The solution to this problem must resolve the following forces: • Accuracy. We should faithfully record what a user or process has done with respect to the use of system resources. • Security. Any information we use to keep track of what the users have done must be protected. Unauthorized reading may reveal sensitive information. Tampering may erase past actions. • Forensics. When a misuse of data occurs, it may be necessary to audit the access operations performed by users to determine possible unauthorized actions, and maybe trace the attacker or understand how the attack occurred. • System improvement. The same misuses may keep occurring; we need to learn from past attacks. • Compliance. We need a way to verify and to prove to third parties that we have complied with institution policies and external regulations. • Performance. We need to minimize the overhead of logging. 73.5. Solution Each time a user accesses some object, we record this access, indicating the user identifier, the type of access, the object accessed and the time when the access happened. The database of access entries must have authentication and authorization systems, and possibly an encryption capability. 73.6. Structure In Figure 164 User operations are logged by the LoggerAuditor. The LoggerAuditor keeps the Log of user accesses, in which each access is described by a LogEntry. The security administrator (SecAdmin) activates or deactivates the Log. The Auditor can read the Log to detect possible unauthorized actions. 73.7. Dynamics Possible use cases include ‘Log user access’, ‘Audit log’, ‘Query log database’. A sequence diagram for the use case ‘Log user access’ is shown in Figure 165. The User performs an operation to apply an access type on some object: operation (accessType, object). The LoggerAuditor adds an entry with this information, and the name of the user, to the Log. The Log creates a LogEntry, adding the time of the operation. 73.8. Implementation The class diagram shown in Figure 164 provides a clear guideline for implementation, since its classes can be directly implemented in any object-oriented language. We need to define commands to activate or deactivate logging, apply filters, indicate devices to be used, allocate amount of storage, and select security mechanisms. One can filter some logging by selecting users, events, importance of events, times, and objects in the filters. Administrative security actions, for example account creation/deletion, assignment of rights and others, must also be logged. Logging is performed by calling methods on the LoggerAuditor class. Every non-filtered user operation should be logged. Logged messages can have levels of importance associated with them. Audit is performed by an auditor reading the log. This can be complemented with manual assessments that include interviewing staff, performing security vulnerability scans, reviewing application and operating system access controls, and analyzing physical access to the systems [1]. The Model-View-Controller pattern can be used to visualize the data using different views during complex statistical analysis of the log data. 73.9. Example Resolved After the incident, the hospital installed a SECURITY LOGGER AND AUDITOR, so in the future such violations can be discovered. 73.10. Consequences The SECURITY LOGGER AND AUDITOR pattern offers the following benefits: • Security. It is possible to add appropriate security mechanisms to protect recorded data, for example access control and/or encryption. • Forensics. The pattern enables forensic auditing of misused data objects. Records of access can be used to determine whether someone has maliciously gained access to data. This pattern can also be used to log access to data objects by system processes. For example, malicious code planted in the system can be tracked by finding processes that have misused objects. • System improvement. By studying how past attacks happened, we can improve the system security. Compliance. Auditing a log can be used to verify and prove that institutional and regulatory policies have been followed. • Performance. We can reduce overhead by parallel or background logging. We can also not log some events not considered significant. Finally, we can merge this log with the recovery log, needed for possible rollback. The pattern has the following potential liabilities: • It can incur significant overhead since each object access has to be logged. • A decision must be made by software designers as to the granularity at which objects are logged. There is a trade-off between security and performance. • It is not easy to perform forensic analysis, and specialists are required. • Protecting the log adds some overhead and cost. 73.11. Variants Most systems have a system logger, used to undo/rollback actions after a system crash. That type of logger has different requirements, but sometimes is merged with the security logger [2]. System logs are of interest to system and database administrators, while security logs are used by security administrators, auditors, and system designers. Another variant could include the automatic raising of alarms by periodic examination of the log, searching records that match a number of rules that characterize known violations. For example, intrusion detection systems use this variant. We can also add logging for reliability, to detect accidental errors. 73.12. Known Uses • Most modern operating systems, including Microsoft Windows [3], AIX [4], Solaris and others have security loggers. • SAP uses both a security audit log and a system log [2]. 73.13. See Also • The Secure Logger is a pattern for J2EE [5]. It defines how to capture application-specific events and exceptions to support security auditing. This pattern is mostly implementation-oriented and does not consider the conceptual aspects discussed in our pattern. It should have been called a ‘security logger’ because it does not include any mechanisms to protect the logged information. • Martin Fowler has an Audit Log analysis pattern [6] for tracking temporal information. The idea is that whenever something significant happens, you write some record indicating what happened and when it happened. • Patterns for authentication: how can we make sure that a subject is who they say they are? • AUTHORIZATION describes how we can control who can access to which resources, and how, in a computer system. 73.14. References [1] Wikipedia contributors. (n.d.). Information security audit. Wikipedia. https://en.wikipedia.org/wiki/Information_security_audit [2] Software AG. (2009). webMethods Audit Logging Guide. http://documentation.softwareag.com/webmethods/wmsuites/wmsuite8_ga/Cross_Product/8-0SP1_Audit_Logging_Guide.pdf [3] Smith, F. R. (n.d.). Auditing Users and Groups with the Windows Security Log. http://www.windowsecurity.com/articles/auditing-users-groups-windows-security-log.html [4] AIX. (n.d.). System Security Auditing. http://www.aixmind.com/?p=1019 [5] Steel, C., Nagappan, R., Lai, R. (2006). Securing the Web Tier: Design Strategies and Best Practices (Chapter 9). Sun. [6] Fowler, M. (n.d.). Audit Log. http://martinfowler.com/ap2/auditLog.html 73.15. Source Fernandez-Buglioni, E. (2013). Security patterns in practice: designing secure architectures using software patterns. John Wiley & Sons."
        }

    ]
}